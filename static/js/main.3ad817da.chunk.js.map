{"version":3,"sources":["game.tsx","computer.tsx","store.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Game","directions","y","x","Computer","maximizingPlayer","heuristicType","maxDepth","timeLimit","startTime","currentTime","outOfTime","numAllyPieces","numAllyKings","numOppPieces","numOppKings","this","game","date","Date","getTime","getBoardStatus","bestMoveVal","depthReached","bestMove","listBestMovesCurrentDepth","legalMovesList","getLegalMoves","board","length","console","log","bestVal","Number","NEGATIVE_INFINITY","i","move","copy","applyMove","min","minVal","MAX_VALUE","push","Math","floor","random","numMoves","depth","easyHeuristic","mediumHeuristic","hardHeuristic","numRows","numCols","boardVal","cntAllyPieces","cntAllyKings","cntOppPieces","cntOppKings","j","numDefendingNeighbors","backBonus","middleBonus","originalPlayer","currentPlayer","player1Moves","player2Moves","MIN_VALUE","alpha","beta","newDate","listLegalMoves","cutoffTest","evalFcn","v","forEach","copyGame","max","maxVal","row","col","state","defense","abs","initialState","actionsToSend","character","respectfulAppeal","russianRules","backwardDirection","players","isRobot","playerTurn","hasArrowSelectedItem","arrowSelectedItemRow","arrowSelectedItemCol","isContiniousMoving","continiousMoving","continiousCaptured","hasSelectedItem","selectedItemRow","selectedItemCol","gameBoard","pieces","tiles","checkers","newGame","setCurrentState","doMove","newBoard","line","slice","listCaptureCol","listCaptureRow","checker","initialRow","initialCol","listVisitedRow","listVisitedCol","startRow","startCol","endRow","endCol","reducer","action","type","color","column","legalMoves","foundedMove","newState","computerPlayer","alphaBetaSearch","printMove","restMoves","Error","dictionary","label_coords","App","memo","useReducer","appState","dispatch","downHandler","e","key","preventDefault","handleTileClick","_renderPieces","playerId","values","keys","values_sorted","countPieces","checkersType","divStyle","top","left","backgroundImage","myClassName","className","id","toString","style","onClick","handlePieceClick","idx","sort","a","b","React","useEffect","window","addEventListener","removeEventListener","setTimeout","href","background","onKeyDown","debug","countTiles","_renderTiles","_renderPult","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.3ad817da.chunk.js","sourcesContent":["\r\nimport Move from \"./move\";\r\n\r\nclass Game {\r\n    // 8x8 board composed of integers from -1 to 4.\r\n    // -1 invalid board space, 0 empty board space\r\n    // 1 -> player 1 normal pieces, 2 -> player 2 normal pieces, 3 -> player 1 kings, 4 -> player 2 kings\r\n    board: number[][]=[];\r\n\r\n    static directions=[{y:1, x:1},{y:-1,x:1},{y:1,x:-1},{y:-1,x:-1}];\r\n\r\n    // set default starting player and time limit\r\n    currentPlayer = 1;\r\n    timeLimit = 3;\r\n\r\n    // При запуске расчета кодов сюда запишется нужное значение (менять в store.ts)\r\n    russianRules = false;\r\n    // board colors\r\n    //public const ANSI_RED = \"\\u001B[91m\";\r\n    //public const ANSI_WHITE_BACKGROUND = \"\\u001B[47m\";\r\n    //public const ANSI_CYAN = \"\\u001B[96m\";\r\n    //public const ANSI_RESET = \"\\u001B[0m\";\r\n    // empty constructor\r\n    constructor() {\r\n        // Проверяю, почему не собирается static, поэтому добавил в конструктор какую-то инициализацию хотя бы... вдруг поможет\r\n        this.currentPlayer = 1;\r\n        this.timeLimit = 3;\r\n    }\r\n\r\n    // copy constructor, used for when AI needs to apply minimax algorithm\r\n    public static Game(game: Game) {\r\n        let newGame=new Game();\r\n        newGame.board = [];\r\n        for (let i = 0; i < game.board.length; i++) {\r\n            newGame.board.push(game.board[i].slice());\r\n        }\r\n        newGame.currentPlayer = game.currentPlayer;\r\n        newGame.timeLimit = game.timeLimit;\r\n        return newGame;\r\n    }\r\n\r\n    public setCurrentState(board: number[][], currentPlayer: number, timeLimit: number): void {\r\n        this.currentPlayer = currentPlayer;\r\n        this.timeLimit = timeLimit;\r\n\r\n        for (let i = 0; i < 8; i++) {\r\n            for (let j = 0; j < 8; j++) {\r\n                if (board[i][j]>=0)\r\n                    this.board[i][j] = board[i][j]%10;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    // initialize board as new game board\r\n    newGame(): void {\r\n        // прервое число - количество строк, второе - колонок\r\n        this.board = new Array(8).fill(0).map(() => new Array(8).fill(0));\r\n        // initialize the board with null spaces as -1, empty spaces as 0, player 1\r\n        // as 1 (red checkers) and player 2 as 2 (blue checkers)\r\n        for (let i = 0; i < 3; i++) {\r\n            for (let j = 0; j < 8; j += 2) {\r\n                if ((i & 1) === 1) {\r\n                    this.board[i][j + 1] = -1;\r\n                    this.board[i][j] = 1;\r\n                } else {\r\n                    this.board[i][j] = -1;\r\n                    this.board[i][j + 1] = 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 3; i < 5; i++) {\r\n            for (let j = 0; j < 8; j += 2) {\r\n                if ((i & 1) === 1) {\r\n                    this.board[i][j + 1] = -1;\r\n                    this.board[i][j] = 0;\r\n                } else {\r\n                    this.board[i][j] = -1;\r\n                    this.board[i][j + 1] = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 5; i < 8; i++) {\r\n            for (let j = 0; j < 8; j += 2) {\r\n                if ((i & 1) === 1) {\r\n                    this.board[i][j + 1] = -1;\r\n                    this.board[i][j] = 2;\r\n                } else {\r\n                    this.board[i][j] = -1;\r\n                    this.board[i][j + 1] = 2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /*\r\n    // load games into board[][] and fill other variables using .txt files following Sable's board format\r\n    loadGameBoard(filename: string): boolean {\r\n        try {\r\n            //BufferedReader reader = new BufferedReader(new FileReader(filename));\r\n            this.board = new Array(8).fill(0).map(() => new Array(8).fill(0));\r\n            for (let i = 0; i < 8; i++) {\r\n                String[] boardValues = reader.readLine().trim().split(\"\\\\s+\");\r\n                if ((i & 1) == 0) {\r\n                    for (int j = 0; j < 8; j += 2) {\r\n                        board[i][j] = -1;\r\n                        board[i][j + 1] = Integer.valueOf(boardValues[j / 2]);\r\n                    }\r\n                } else {\r\n                    for (int j = 0; j < 8; j += 2) {\r\n                        board[i][j] = Integer.valueOf(boardValues[j / 2]);\r\n                        board[i][j + 1] = -1;\r\n                    }\r\n                }\r\n            }\r\n            String currPlayer = reader.readLine();\r\n            currentPlayer = Integer.valueOf(currPlayer);\r\n            String cpuTimeLimit = reader.readLine();\r\n            timeLimit = Integer.valueOf(cpuTimeLimit);\r\n            return true;\r\n        } catch (FileNotFoundException e) {\r\n            //e.printStackTrace();\r\n            System.out.println(\"File not found.\");\r\n            return false;\r\n        } catch (IOException e) {\r\n            //e.printStackTrace();\r\n            System.out.println(\"IO exception occurred.\");\r\n            return false;\r\n        }\r\n    }\r\n    // print board corresponding to board[][]\r\n    void printBoard() {\r\n        System.out.println(\"      0      1      2      3      4      5      6      7   \");\r\n        for (int i = 0; i < 8; i++) {\r\n            System.out.print(\"   \");\r\n            if ((i & 1) == 0) { // print even rows\r\n                // padding with extra row of black/white space\r\n                for (int j = 0; j < 4; j++) {\r\n                    System.out.print(ANSI_WHITE_BACKGROUND + \"       \" + ANSI_RESET + \"       \");\r\n                }\r\n\r\n                System.out.println(\"\");\r\n                System.out.print(\" \" + (i) + \" \");\r\n\r\n                for (int j = 0; j < 8; j++) {\r\n                    printCorrectPiece(board[i][j]);\r\n                }\r\n\r\n                System.out.println(\"\");\r\n                System.out.print(\"   \");\r\n\r\n                // padding with extra row of black/white space\r\n                for (int j = 0; j < 4; j++) {\r\n                    System.out.print(ANSI_WHITE_BACKGROUND + \"       \" + ANSI_RESET + \"       \");\r\n                }\r\n\r\n            } else { //print odd rows\r\n                // padding with extra row of black/white space\r\n                for (int j = 0; j < 4; j++) {\r\n                    System.out.print(\"       \" + ANSI_WHITE_BACKGROUND + \"       \" + ANSI_RESET);\r\n                }\r\n\r\n                System.out.println(\"\");\r\n                System.out.print(\" \" + (i) + \" \");\r\n\r\n                for (int j = 0; j < 8; j++) {\r\n                    printCorrectPiece(board[i][j]);\r\n                }\r\n\r\n                System.out.println(\"\");\r\n                System.out.print(\"   \");\r\n\r\n                // padding with extra row of black/white space\r\n                for (int j = 0; j < 4; j++) {\r\n                    System.out.print(\"       \" + ANSI_WHITE_BACKGROUND + \"       \" + ANSI_RESET);\r\n                }\r\n            }\r\n\r\n            System.out.println(\"\");\r\n        }\r\n    }\r\n    // helper function for printBoard()\r\n    void printCorrectPiece(int val) {\r\n        switch (val) {\r\n            case -1:\r\n                System.out.print(ANSI_WHITE_BACKGROUND + \"       \" + ANSI_RESET);\r\n                break;\r\n            case 0:\r\n                System.out.print(\"       \");\r\n                break;\r\n            case 1:\r\n                System.out.print(ANSI_RED + \"   -   \" + ANSI_RESET);\r\n                break;\r\n            case 2:\r\n                System.out.print(ANSI_CYAN + \"   .   \" + ANSI_RESET);\r\n                break;\r\n            case 3:\r\n                System.out.print(ANSI_RED + \"   *   \" + ANSI_RESET);\r\n                break;\r\n            case 4:\r\n                System.out.print(ANSI_CYAN + \"   0   \" + ANSI_RESET);\r\n                break;\r\n\r\n        }\r\n    }\r\n    */\r\n\r\n    // function to iterate over all pieces in the board and get legal moves for current player\r\n    getLegalMoves(state: number[][]): Move[] {\r\n        //List<Move> slideMoves = new ArrayList<Move>();\r\n        //List<Move> jumpMoves = new ArrayList<Move>();\r\n        let slideMoves: Move[]=[];\r\n        let jumpMoves: Move[]=[];\r\n\r\n        // iterate over the entire board, check for legal moves for all pieces of current player\r\n        for (let i = 0; i < 8; i++) {\r\n            for (let j = 0; j < 8; j++) {\r\n                if (this.currentPlayer === 1) {\r\n                    if (this.board[i][j] === 1 || this.board[i][j] === 3) {\r\n                        this.getJumps(jumpMoves, null, this.board[i][j], i, j, state);\r\n                        // stop looking for slide moves if we find any jump moves\r\n                        if (jumpMoves.length===0) {\r\n                            this.getSlides(slideMoves, this.board[i][j], i, j, this.board);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (this.board[i][j] === 2 || this.board[i][j] === 4) {\r\n                        this.getJumps(jumpMoves, null, this.board[i][j], i, j, state);\r\n                        // stop looking for slide moves if we find any jump moves\r\n                        if (jumpMoves.length===0) {\r\n                            this.getSlides(slideMoves, this.board[i][j], i, j, this.board);\r\n                        }\r\n\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return jumpMoves.length===0 ? slideMoves : jumpMoves;\r\n    }\r\n    // function which mutates the moves list it takes as a parameter\r\n    getSlides(moves: Move[], pieceType: number, startRow: number, startCol: number, state:number[][]): void {\r\n        //ArrayList<Integer> endRow = new ArrayList<Integer>();\r\n        //ArrayList<Integer> endCol = new ArrayList<Integer>();\r\n        let endRow: number[]=[];\r\n        let endCol: number[]=[];\r\n        let kingMoves = [];\r\n\r\n        switch (pieceType) {\r\n            case 1:\r\n                endRow.push(startRow + 1);\r\n                endRow.push(startRow + 1);\r\n                endCol.push(startCol + 1);\r\n                endCol.push(startCol - 1);\r\n                break;\r\n            case 2:\r\n                endRow.push(startRow - 1);\r\n                endRow.push(startRow - 1);\r\n                endCol.push(startCol + 1);\r\n                endCol.push(startCol - 1);\r\n                break;\r\n            case 3:\r\n            case 4:\r\n                if (this.russianRules)\r\n                {\r\n                    // Дамка ходит в любом направлении\r\n                    for (let dir=0; dir<4; dir++)\r\n                    {\r\n                        let y=startRow;\r\n                        let x=startCol;\r\n                        let offset_y=Game.directions[dir].y;\r\n                        let offset_x=Game.directions[dir].x;\r\n                        for (let offset=1; offset<=7; offset++)\r\n                        {\r\n                            y+=offset_y;\r\n                            x+=offset_x;\r\n                            // если вышли за границы\r\n                            if (y < 0 || y > 7 || x < 0 || x > 7) break;\r\n                            endRow.push(y);\r\n                            endCol.push(x);\r\n                            kingMoves.push({len: offset, dir_y: Game.directions[dir].y, dir_x: Game.directions[dir].x});\r\n                        }\r\n                    }\r\n                } else\r\n                {\r\n                    endRow.push(startRow + 1);\r\n                    endRow.push(startRow + 1);\r\n                    endRow.push(startRow - 1);\r\n                    endRow.push(startRow - 1);\r\n                    endCol.push(startCol + 1);\r\n                    endCol.push(startCol - 1);\r\n                    endCol.push(startCol + 1);\r\n                    endCol.push(startCol - 1);\r\n                    break;\r\n                }\r\n        }\r\n\r\n        let numMoves = endRow.length;\r\n\r\n        for (let i = 0; i < numMoves; i++) {\r\n            // check if inside the board\r\n            if (endRow[i] < 0 || endRow[i] > 7 || endCol[i] < 0 || endCol[i] > 7) continue;\r\n            // check if end position is occupied\r\n            if (state[endRow[i]][endCol[i]] !== 0) continue;\r\n            if ((pieceType===3||pieceType===4)&&this.russianRules)\r\n            {\r\n                let cantMove=false;\r\n                let kingMove=kingMoves[i];\r\n                // если это дамка, то надо, чтобы в промежуточных положениях никого не было\r\n                // TODO и здесь тоже цикл сделал от 1 вместо 0, а то она проверяла сама себя\r\n                for (let j=1; j<kingMoves[i].len; j++)\r\n                {\r\n                    if (state[startRow+kingMove.dir_y*j][startCol+kingMove.dir_x*j] !== 0)\r\n                    {\r\n                        cantMove=true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (cantMove)\r\n                    continue;\r\n\r\n            }\r\n            // move was legal so add it to list\r\n            moves.push(Move.fill_1(startRow, startCol, endRow[i], endCol[i], state));\r\n        }\r\n    }\r\n    // function which mutates the moves list it takes as a parameter\r\n    getJumps(moves: Move[], move: Move|null, pieceType: number, startRow: number, startCol: number, state: number[][]): void  {\r\n        // endRow/endCol list to add all possible squares to move to from each piece\r\n        // captureRow/captureCol list to add all possible squares that can be captured\r\n        let endRow: number[]=[];\r\n        let endCol: number[]=[];\r\n        let captureRow: number[]=[];\r\n        let captureCol: number[]=[];\r\n        let kingMoves = [];\r\n\r\n        if (this.russianRules)\r\n        {\r\n            switch (pieceType) {\r\n                case 1:\r\n                case 2:\r\n                    // все рубят в любом направлении\r\n                    endRow.push(startRow + 2);\r\n                    endRow.push(startRow + 2);\r\n                    endRow.push(startRow - 2);\r\n                    endRow.push(startRow - 2);\r\n                    endCol.push(startCol - 2);\r\n                    endCol.push(startCol + 2);\r\n                    endCol.push(startCol - 2);\r\n                    endCol.push(startCol + 2);\r\n                    captureRow.push(startRow + 1);\r\n                    captureRow.push(startRow + 1);\r\n                    captureRow.push(startRow - 1);\r\n                    captureRow.push(startRow - 1);\r\n                    captureCol.push(startCol - 1);\r\n                    captureCol.push(startCol + 1);\r\n                    captureCol.push(startCol - 1);\r\n                    captureCol.push(startCol + 1);\r\n                    break;\r\n                case 3:\r\n                case 4:\r\n                    // Дамка ходит (рубит) в любом направлении на любое расстояние\r\n                    for (let dir=0; dir<4; dir++)\r\n                    {\r\n                        let offset_y=Game.directions[dir].y;\r\n                        let offset_x=Game.directions[dir].x;\r\n                        // здесь рубят\r\n                        let y=startRow+offset_y;\r\n                        let x=startCol+offset_x;\r\n\r\n                        for (let offset=1; offset<=7; offset++)\r\n                        {\r\n                            // а тут останавливаются\r\n                            y+=offset_y;\r\n                            x+=offset_x;\r\n                            // если вышли за границы\r\n                            if (y < 0 || y > 7 || x < 0 || x > 7) break;\r\n                            endRow.push(y);\r\n                            endCol.push(x);\r\n                            captureRow.push(y-offset_y);\r\n                            captureCol.push(x-offset_x);\r\n                            // TODO\r\n                            kingMoves.push({len: offset, dir_y: Game.directions[dir].y, dir_x: Game.directions[dir].x});\r\n                        }\r\n                    }\r\n                    break;\r\n            }\r\n\r\n        } else\r\n        {\r\n            switch (pieceType) {\r\n                case 1:\r\n                    endRow.push(startRow + 2);\r\n                    endRow.push(startRow + 2);\r\n                    endCol.push(startCol - 2);\r\n                    endCol.push(startCol + 2);\r\n                    captureRow.push(startRow + 1);\r\n                    captureRow.push(startRow + 1);\r\n                    captureCol.push(startCol - 1);\r\n                    captureCol.push(startCol + 1);\r\n                    break;\r\n                case 2:\r\n                    endRow.push(startRow - 2);\r\n                    endRow.push(startRow - 2);\r\n                    endCol.push(startCol - 2);\r\n                    endCol.push(startCol + 2);\r\n                    captureRow.push(startRow - 1);\r\n                    captureRow.push(startRow - 1);\r\n                    captureCol.push(startCol - 1);\r\n                    captureCol.push(startCol + 1);\r\n                    break;\r\n                case 3:\r\n                case 4:\r\n                    endRow.push(startRow + 2);\r\n                    endRow.push(startRow + 2);\r\n                    endRow.push(startRow - 2);\r\n                    endRow.push(startRow - 2);\r\n                    endCol.push(startCol - 2);\r\n                    endCol.push(startCol + 2);\r\n                    endCol.push(startCol - 2);\r\n                    endCol.push(startCol + 2);\r\n                    captureRow.push(startRow + 1);\r\n                    captureRow.push(startRow + 1);\r\n                    captureRow.push(startRow - 1);\r\n                    captureRow.push(startRow - 1);\r\n                    captureCol.push(startCol - 1);\r\n                    captureCol.push(startCol + 1);\r\n                    captureCol.push(startCol - 1);\r\n                    captureCol.push(startCol + 1);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        let numMoves = endRow.length;\r\n        let anyValidMoves = false;\r\n        // new boolean[numMoves]\r\n        let whichAreValid = new Array(numMoves).fill(false);\r\n\r\n        for (let i = 0; i < numMoves; i++) {\r\n            // check if inside the board\r\n            if (endRow[i] < 0 || endRow[i] > 7 || endCol[i] < 0 || endCol[i] > 7) continue;\r\n            // check if end position is occupied\r\n            if (move !== null) {\r\n                // check if end position is occupied but allow piece to land on initial position\r\n                if (state[endRow[i]][endCol[i]] !== 0 && state[endRow[i]][endCol[i]] !== state[move.initialRow][move.initialCol]) continue;\r\n                // check if we're trying to capture a piece we've already captured in current move\r\n                //if (move.capturedSquares.has(new Pair(captureRow[i], captureCol[i]))) continue;\r\n                if (move.capturedSquares.has(captureRow[i]*100+captureCol[i])) continue;\r\n            }\r\n            else {\r\n                // if move is null, make sure end position isn't occupied\r\n                if (state[endRow[i]][endCol[i]] !== 0) continue;\r\n            }\r\n\r\n            if ((pieceType===3||pieceType===4)&&this.russianRules)\r\n            {\r\n                let cantMove=false;\r\n                let kingMove=kingMoves[i];\r\n                // если это дамка, то надо, чтобы в промежуточных положениях никого не было\r\n                // отличие от перемещения, тут на 1 итерацию меньше (начинается с 1)\r\n                for (let j=1; j<kingMoves[i].len; j++)\r\n                {\r\n                    if (state[startRow+kingMove.dir_y*j][startCol+kingMove.dir_x*j] !== 0)\r\n                    {\r\n                        cantMove=true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (cantMove)\r\n                    continue;\r\n            }\r\n\r\n\r\n            // check if captured positions were occupied by the opposite player\r\n            if (this.currentPlayer === 1 && !(state[captureRow[i]][captureCol[i]] === 2 || state[captureRow[i]][captureCol[i]] === 4)) continue;\r\n\r\n            if (this.currentPlayer === 2 && !(state[captureRow[i]][captureCol[i]] === 1 || state[captureRow[i]][captureCol[i]] === 3)) continue;\r\n\r\n            // if we got this far, it means the move is valid\r\n            anyValidMoves = true;\r\n            whichAreValid[i] = true;\r\n        }\r\n\r\n        if (move !== null && !anyValidMoves) {\r\n            moves.push(move);\r\n            return;\r\n        }\r\n\r\n        if (move === null && anyValidMoves) {\r\n            for (let i = 0; i < numMoves; i++) {\r\n                if (whichAreValid[i]) {\r\n                    let newMove = Move.fill_1(startRow, startCol, endRow[i], endCol[i], state);\r\n                    newMove.initialRow = startRow;\r\n                    newMove.initialCol = startCol;\r\n                    newMove.startRow = startRow;\r\n                    newMove.startCol = startCol;\r\n                    newMove.endRow = endRow[i];\r\n                    newMove.endCol = endCol[i];\r\n                    newMove.listCaptureRow.push(captureRow[i]);\r\n                    newMove.listCaptureCol.push(captureCol[i]);\r\n                    newMove.listVisitedRow.push(endRow[i]);\r\n                    newMove.listVisitedCol.push(endCol[i]);\r\n                    newMove.capturedSquares.add(captureRow[i]*100+captureCol[i]);\r\n                    this.getJumps(moves, newMove, pieceType, newMove.endRow, newMove.endCol, state);\r\n                }\r\n            }\r\n        }\r\n        if (move !== null && anyValidMoves) {\r\n            for (let i = 0; i < numMoves; i++) {\r\n                if (whichAreValid[i]) {\r\n                    let newMove = Move.fill_2(move);\r\n                    newMove.startRow = startRow;\r\n                    newMove.startCol = startCol;\r\n                    newMove.endRow = endRow[i];\r\n                    newMove.endCol = endCol[i];\r\n                    newMove.listCaptureRow.push(captureRow[i]);\r\n                    newMove.listCaptureCol.push(captureCol[i]);\r\n                    newMove.listVisitedRow.push(endRow[i]);\r\n                    newMove.listVisitedCol.push(endCol[i]);\r\n                    newMove.capturedSquares.add(captureRow[i]*100+captureCol[i]);\r\n                    this.getJumps(moves, newMove, pieceType, newMove.endRow, newMove.endCol, state);\r\n                }\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    // function to a apply a move to the board\r\n    applyMove(move: Move, state: number[][]): void {\r\n        // handle slide move\r\n        if (move.listCaptureRow.length===0) {\r\n            // update end position to match current piece\r\n            state[move.endRow][move.endCol] = state[move.startRow][move.startCol];\r\n            // make the piece a king if it is in the back row of the opposite team's side\r\n            if (state[move.startRow][move.startCol] === 1 && move.endRow === 7) {\r\n                state[move.endRow][move.endCol] += 2;\r\n            }\r\n            if (state[move.startRow][move.startCol] === 2 && move.endRow === 0) {\r\n                state[move.endRow][move.endCol] += 2;\r\n            }\r\n            // clear initial position\r\n            state[move.startRow][move.startCol] = 0;\r\n        }\r\n        // handle jump move\r\n        else {\r\n            // clear capture positions\r\n            for (let i = 0; i < move.listCaptureRow.length; i++) {\r\n                state[move.listCaptureRow[i]][move.listCaptureCol[i]] = 0;\r\n            }\r\n            // update end position to match current piece\r\n            state[move.endRow][move.endCol] = state[move.initialRow][move.initialCol];\r\n            // make the piece a king if it is in the back row of the opposite team's side\r\n            if (state[move.initialRow][move.initialCol] === 1 && move.endRow === 7) {\r\n                state[move.endRow][move.endCol] += 2;\r\n            }\r\n            if (state[move.initialRow][move.initialCol] === 2 && move.endRow === 0) {\r\n                state[move.endRow][move.endCol] += 2;\r\n            }\r\n            //  clear initial position\r\n            state[move.initialRow][move.initialCol] = 0;\r\n        }\r\n        // switch the currentPlayer\r\n        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;\r\n        //System.out.println(\"Current Player: \" + currentPlayer);\r\n    }\r\n    // print moves and in the case of jumps show intermediate jumps\r\n    printListMoves(movesList: Move[]) {\r\n        if (movesList[0].listCaptureRow.length===0) {\r\n            for (let i = 0; i < movesList.length; i++) {\r\n                console.debug(\"Move \" + i + \": (\" + movesList[i].startRow + \",\" + movesList[i].startCol + \") --> (\" + movesList[i].endRow + \",\" + movesList[i].endCol + \")\");\r\n\r\n            }\r\n        } else {\r\n            for (let i = 0; i < movesList.length; i++) {\r\n                console.debug(\"\\n\");\r\n                console.debug(\"Move \" + i + \": (\" + movesList[i].initialRow + \",\" + movesList[i].initialCol + \")\");\r\n                for (let j = 0; j < movesList[i].listVisitedRow.length; j++) {\r\n                    console.debug(\" --> (\" + movesList[i].listVisitedRow[j] + \",\" + movesList[i].listVisitedCol[j] + \")\");\r\n                }\r\n            }\r\n            console.debug(\"\");\r\n        }\r\n        console.debug(\"\");\r\n    }\r\n    // print individual move\r\n    printMove(move: Move) {\r\n        if (move.listCaptureRow.length===0){\r\n            console.debug(\"Move \" + \": (\" + move.startRow + \",\" + move.startCol + \") --> (\" + move.endRow + \",\" + move.endCol + \")\");\r\n        } else {\r\n            console.debug(\"Move \" + \": (\" + move.initialRow + \",\" + move.initialCol + \")\");\r\n            for (let j = 0; j < move.listVisitedRow.length; j++) {\r\n                console.debug(\" --> (\" + move.listVisitedRow[j] + \",\" + move.listVisitedCol[j] + \")\");\r\n            }\r\n            console.debug(\"\");\r\n        }\r\n        console.debug(\"\");\r\n    }\r\n    /*\r\n    // print help note which shows what symbols represent the pieces of each player\r\n    void printNote() {\r\n        System.out.println(\"Player 1 is\" + ANSI_RED + \"  -  \" + ANSI_RESET + \"(normal piece) and\" + ANSI_RED + \"  *  \" + ANSI_RESET + \"(king)\");\r\n        System.out.println(\"Player 2 is\" + ANSI_CYAN + \"  .  \" + ANSI_RESET + \"(normal piece) and\" + ANSI_CYAN + \"  0  \" + ANSI_RESET + \"(king)\");\r\n        System.out.println(\"\");\r\n    }\r\n    */\r\n}\r\n\r\nexport default Game;\r\n","import Game from './game';\r\nimport Move from './move';\r\n\r\nclass Computer\r\n{\r\n    // maximizingPlayer specifies which player the computer is playing for.\r\n    maximizingPlayer=0;\r\n    // maxDepth used to keep track of depth reached using iterative deepening search\r\n    maxDepth=0;\r\n    // default time limit\r\n    timeLimit = 2;\r\n    // heuristicType specifies which heuristic is used for the computer\r\n    heuristicType=0;\r\n    // startTime and currentTime used to ensure search doesn't exceed time limit\r\n    startTime = 0; // long\r\n    currentTime = 0; // long\r\n    outOfTime = false;\r\n    // used to keep track of number of pieces on board prior to search\r\n    numAllyPieces = 0;\r\n    numAllyKings = 0;\r\n    numOppPieces = 0;\r\n    numOppKings = 0;\r\n\r\n    // evaluation function for mini-max.\r\n    constructor(maximizingPlayer: number, heuristicType: number) {\r\n        this.maximizingPlayer = maximizingPlayer;\r\n        this.heuristicType = heuristicType;\r\n    }\r\n\r\n    // iterative deepening mini-max search with alpha beta pruning\r\n    // Move\r\n    public alphaBetaSearch(game: Game): Move|null {\r\n        // begin by getting start time for search\r\n        let date = new Date();\r\n        this.startTime = date.getTime();\r\n        // initialize necessary variables\r\n        this.getBoardStatus(game);\r\n        this.outOfTime = false;\r\n        let bestMoveVal = 0;\r\n        let depthReached = 0;\r\n        let bestMove:Move|null = null;\r\n        let listBestMovesCurrentDepth: Move[]=[];\r\n        let legalMovesList:Move[] = game.getLegalMoves(game.board);\r\n        // just return move if only 1 move available\r\n        if (legalMovesList.length === 1) {\r\n            console.log(\"Searched to depth 0 in 0 seconds.\");\r\n            return legalMovesList[0];\r\n        }\r\n        // actual search (iterative deepening mini-max w/ alpha beta pruning).\r\n        for (this.maxDepth = 0; this.maxDepth < 15 && !this.outOfTime; this.maxDepth++) {\r\n            listBestMovesCurrentDepth = [];\r\n            let bestVal = Number.NEGATIVE_INFINITY;\r\n            for (let i=0; i<legalMovesList.length; i++)\r\n            {\r\n                let move=legalMovesList[i];\r\n                let copy = Game.Game(game);\r\n                copy.applyMove(move, copy.board);\r\n                //let min = this.minVal(copy, Number.MIN_VALUE, Number.MAX_VALUE, 0);\r\n                let min = this.minVal(copy, Number.NEGATIVE_INFINITY, Number.MAX_VALUE, 0);\r\n                if (this.outOfTime) break;\r\n                // System.out.println(\"Possible move val: \" + min);\r\n                if (min === bestVal) {\r\n                    listBestMovesCurrentDepth.push(move);\r\n                }\r\n                if (min > bestVal) {\r\n                    listBestMovesCurrentDepth.length=0;\r\n                    listBestMovesCurrentDepth.push(move);\r\n                    bestVal = min;\r\n                }\r\n                if (bestVal === Number.MAX_VALUE) break;\r\n            }\r\n            if (!this.outOfTime) {\r\n                //let chosenMove = random.nextInt(listBestMovesCurrentDepth.length);\r\n                let chosenMove=Math.floor(Math.random()*listBestMovesCurrentDepth.length);\r\n                bestMove = listBestMovesCurrentDepth[chosenMove];\r\n                depthReached = this.maxDepth;\r\n                bestMoveVal = bestVal;\r\n            }\r\n            if (bestMoveVal === Number.MAX_VALUE) break;\r\n        }\r\n        // System.out.println(\"Best move value \" + bestMoveVal);\r\n        console.log(\"Searched to depth \" + depthReached + \" in \" + ((this.currentTime-this.startTime)/1000) + \" seconds.\");\r\n        return bestMove;\r\n    }\r\n    // check if we've reached leaf nodes or maximum depth\r\n    public cutoffTest(numMoves: number, depth: number) {\r\n        if (numMoves === 0 || depth === this.maxDepth){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    // eval function decides the heuristic used to calculate value of leaf nodes\r\n    public evalFcn(game: Game): number {\r\n        switch (this.heuristicType) {\r\n            case 1:\r\n                return this.easyHeuristic(game);\r\n            case 2:\r\n                return this.mediumHeuristic(game);\r\n            case 3:\r\n                return this.hardHeuristic(game);\r\n            default:\r\n                return this.hardHeuristic(game);\r\n        }\r\n    }\r\n    // heuristic which takes into account: number of pieces, defending neighbors, backrow protectors, closeness to becoming king,\r\n    // and number of moves each player has for given board. also forces trades when ahead.\r\n    public hardHeuristic(game: Game): number {\r\n        let numRows = game.board.length;\r\n        let numCols = game.board[0].length;\r\n        let boardVal = 0;\r\n        let cntAllyPieces = 0;\r\n        let cntAllyKings = 0;\r\n        let cntOppPieces = 0;\r\n        let cntOppKings = 0;\r\n\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (this.maximizingPlayer === 1){\r\n                    switch(game.board[i][j]) {\r\n                        case 1:\r\n                            cntAllyPieces++;\r\n                            boardVal += this.numDefendingNeighbors(i, j, game.board) * 50 + this.backBonus(i) + (15 * i) + this.middleBonus(i, j);\r\n                            break;\r\n                        case 2:\r\n                            cntOppPieces++;\r\n                            boardVal -= this.numDefendingNeighbors(i, j, game.board) * 50 + this.backBonus(i) + (15 * (7 - i)) + this.middleBonus(i, j);\r\n                            break;\r\n                        case 3:\r\n                            cntAllyKings++;\r\n                            boardVal += this.middleBonus(i,j);\r\n                            break;\r\n                        case 4:\r\n                            cntOppKings++;\r\n                            boardVal -= this.middleBonus(i,j);\r\n                            break;\r\n                    }\r\n                } else {\r\n                    switch(game.board[i][j]) {\r\n                        case 1:\r\n                            cntOppPieces++;\r\n                            boardVal -= this.numDefendingNeighbors(i, j, game.board) * 50 + this.backBonus(i)  + (15 * i) + this.middleBonus(i, j);\r\n                            break;\r\n                        case 2:\r\n                            cntAllyPieces++;\r\n                            boardVal += this.numDefendingNeighbors(i, j, game.board) * 50 + this.backBonus(i) + (15 * (7 - i)) + this.middleBonus(i, j);;\r\n                            break;\r\n                        case 3:\r\n                            cntOppKings++;\r\n                            boardVal -= this.middleBonus(i, j);\r\n                            break;\r\n                        case 4:\r\n                            cntAllyKings++;\r\n                            boardVal += this.middleBonus(i, j);\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // force trades when ahead\r\n        if (this.numAllyPieces + this.numAllyKings > this.numOppPieces + this.numOppKings && cntOppPieces + cntOppKings !== 0 && this.numOppPieces + this.numOppKings !== 0 && this.numOppKings !== 1) {\r\n            if ((cntAllyPieces + cntAllyKings)/(cntOppPieces + cntOppKings) > (this.numAllyPieces + this.numAllyKings)/(this.numOppPieces + this.numOppKings)) {\r\n                boardVal += 150;\r\n            } else {\r\n                boardVal -= 150;\r\n            }\r\n        }\r\n\r\n        boardVal += 600 * cntAllyPieces + 1000 * cntAllyKings - 600 * cntOppPieces - 1000 * cntOppKings;\r\n\r\n        // heavy computation to see how many moves each player has, dont do until players have under 6 pieces\r\n        if (this.numOppPieces + this.numOppKings < 6 || this.numAllyPieces + this.numAllyKings < 6) {\r\n            let originalPlayer = game.currentPlayer;\r\n            game.currentPlayer = 1;\r\n            let player1Moves: Move[] = game.getLegalMoves(game.board);\r\n            game.currentPlayer = 2;\r\n            let player2Moves: Move[] = game.getLegalMoves(game.board);\r\n            game.currentPlayer = originalPlayer;\r\n\r\n            if (player1Moves.length===0) {\r\n                return this.maximizingPlayer === 1 ? Number.NEGATIVE_INFINITY : Number.MAX_VALUE;\r\n            }\r\n\r\n            if (player2Moves.length===0) {\r\n                return this.maximizingPlayer === 2 ? Number.NEGATIVE_INFINITY : Number.MAX_VALUE;\r\n            }\r\n        }\r\n\r\n        if (cntOppPieces + cntOppKings === 0 && cntAllyPieces + cntAllyKings > 0) {\r\n            boardVal = Number.MAX_VALUE;\r\n        }\r\n\r\n        if (cntAllyPieces + cntAllyKings === 0 && cntOppPieces + cntOppKings > 0) {\r\n            boardVal -= Number.MIN_VALUE;\r\n        }\r\n\r\n        return boardVal;\r\n    }\r\n\r\n    public mediumHeuristic(game: Game): number {\r\n        let numRows = game.board.length;\r\n        let numCols = game.board[0].length;\r\n        let boardVal = 0;\r\n\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (this.maximizingPlayer === 1){\r\n                    switch(game.board[i][j]) {\r\n                        case 1:\r\n                            boardVal += 3 + (i * 0.5) + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal += 1;\r\n                            }\r\n                            if (i === 0) {\r\n                                boardVal += 2;\r\n                            }\r\n                            break;\r\n                        case 2:\r\n                            boardVal -= 3 + ((7 - i) * 0.5) + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal -= 1;\r\n                            }\r\n                            if (i === 7) {\r\n                                boardVal -= 2;\r\n                            }\r\n                            break;\r\n                        case 3:\r\n                            boardVal += 5 + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal += 1;\r\n                            }\r\n                            if (i === 0) {\r\n                                boardVal += 2;\r\n                            }\r\n                            break;\r\n                        case 4:\r\n                            boardVal -= 5 + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal -= 1;\r\n                            }\r\n                            if (i === 7) {\r\n                                boardVal -= 2;\r\n                            }\r\n                            break;\r\n                    }\r\n                } else {\r\n                    switch(game.board[i][j]) {\r\n                        case 1:\r\n                            boardVal -= 3 + (i * 0.5) + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal -= 1;\r\n                            }\r\n                            if (i === 0) {\r\n                                boardVal -= 2;\r\n                            }\r\n                            break;\r\n                        case 2:\r\n                            boardVal += 3 + ((7 - i) * 0.5) + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal += 1;\r\n                            }\r\n                            if (i === 7) {\r\n                                boardVal += 2;\r\n                            }\r\n                            break;\r\n                        case 3:\r\n                            boardVal -= 5 + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal -= 1;\r\n                            }\r\n                            if (i === 0) {\r\n                                boardVal -= 2;\r\n                            }\r\n                            break;\r\n                        case 4:\r\n                            boardVal += 5 + this.numDefendingNeighbors(i, j, game.board);\r\n                            if (j === 0 || j === 8) {\r\n                                boardVal += 1;\r\n                            }\r\n                            if (i === 7) {\r\n                                boardVal += 2;\r\n                            }\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return boardVal;\r\n    }\r\n\r\n    public easyHeuristic(game: Game): number {\r\n        let numRows = game.board.length;\r\n        let numCols = game.board[0].length;\r\n        let boardVal = 0;\r\n\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (this.maximizingPlayer === 1){\r\n                    switch(game.board[i][j]) {\r\n                        case 1:\r\n                            boardVal += 3;\r\n                            break;\r\n                        case 2:\r\n                            boardVal -= 3;\r\n                            break;\r\n                        case 3:\r\n                            boardVal += 5;\r\n                            break;\r\n                        case 4:\r\n                            boardVal -= 5;\r\n                            break;\r\n                    }\r\n                } else {\r\n                    switch(game.board[i][j]) {\r\n                        case 1:\r\n                            boardVal -= 3;\r\n                            break;\r\n                        case 2:\r\n                            boardVal += 3;\r\n                            break;\r\n                        case 3:\r\n                            boardVal -= 5;\r\n                            break;\r\n                        case 4:\r\n                            boardVal += 5;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return boardVal;\r\n    }\r\n    // minimax with alpha beta pruning\r\n    public maxVal(game: Game, alpha: number, beta: number, depth: number): number {\r\n        // check if ran out of time for search\r\n        let newDate = new Date();\r\n        this.currentTime = newDate.getTime();\r\n        if ((this.currentTime - this.startTime) >= this.timeLimit * 990) {\r\n            this.outOfTime = true;\r\n            return 0;\r\n        }\r\n        // actual max algorithm\r\n        let listLegalMoves: Move[] = game.getLegalMoves(game.board);\r\n        if (this.cutoffTest(listLegalMoves.length, depth)) {\r\n            return this.evalFcn(game);\r\n        }\r\n        let v = Number.NEGATIVE_INFINITY;\r\n        listLegalMoves.forEach(move => {\r\n            let copyGame = Game.Game(game);\r\n            copyGame.applyMove(move, copyGame.board);\r\n            v = Math.max(v, this.minVal(copyGame, alpha, beta, depth + 1));\r\n            if (v >= beta) return v;\r\n            alpha = Math.max(alpha, v);\r\n        });\r\n        return v;\r\n    }\r\n\r\n    public minVal(game: Game, alpha: number, beta: number, depth: number): number {\r\n        // check if ran out of time for search\r\n        let newDate = new Date();\r\n        this.currentTime = newDate.getTime();\r\n        if ((this.currentTime - this.startTime) > this.timeLimit * 990) {\r\n            this.outOfTime = true;\r\n            return 0;\r\n        }\r\n        // actual min algorithm\r\n        let listLegalMoves: Move[] = game.getLegalMoves(game.board);\r\n        if (this.cutoffTest(listLegalMoves.length, depth)) {\r\n            return this.evalFcn(game);\r\n        }\r\n        let v = Number.MAX_VALUE;\r\n        listLegalMoves.forEach(move => {\r\n            let copyGame = Game.Game(game);\r\n            copyGame.applyMove(move, copyGame.board);\r\n            v = Math.min(v, this.maxVal(copyGame, alpha, beta, depth + 1));\r\n            if (v <= alpha) return v;\r\n            beta = Math.min(beta, v);\r\n        });\r\n        return v;\r\n    }\r\n    // gets number of neighbors for a piece on the board\r\n    public numDefendingNeighbors(row: number, col: number, state: number[][]): number {\r\n        let defense = 0;\r\n        switch (state[row][col]) {\r\n            case 1:\r\n                if (row + 1 < state.length && col + 1 < state[0].length) {\r\n                    if ((state[row + 1][col + 1] & 1) === 1) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row + 1 < state.length && col - 1 >= 0) {\r\n                    if ((state[row + 1][col - 1] & 1) === 1) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                break;\r\n            case 2:\r\n                if (row - 1 >= 0 && col + 1 < state[0].length) {\r\n                    if ((state[row - 1][col + 1] & 1) === 0) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row - 1 >= 0 && col - 1 >= 0) {\r\n                    if ((state[row - 1][col - 1] & 1) === 0) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                break;\r\n            case 3:\r\n                if (row + 1 < state.length && col + 1 < state[0].length) {\r\n                    if ((state[row + 1][col + 1] & 1) === 1) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row + 1 < state.length && col - 1 >= 0) {\r\n                    if ((state[row + 1][col - 1] & 1) === 1) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row - 1 >= 0 && col + 1 < state[0].length) {\r\n                    if ((state[row - 1][col + 1] & 1) === 1) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row - 1 >= 0 && col - 1 >= 0) {\r\n                    if ((state[row - 1][col - 1] & 1) === 1) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                break;\r\n            case 4:\r\n                if (row + 1 < state.length && col + 1 < state[0].length) {\r\n                    if ((state[row + 1][col + 1] & 1) === 0) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row + 1 < state.length && col - 1 >= 0) {\r\n                    if ((state[row + 1][col - 1] & 1) === 0) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row - 1 >= 0 && col + 1 < state[0].length) {\r\n                    if ((state[row - 1][col + 1] & 1) === 0) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                if (row - 1 >= 0 && col - 1 >= 0) {\r\n                    if ((state[row - 1][col - 1] & 1) === 0) {\r\n                        defense += 1;\r\n                    }\r\n                }\r\n                break;\r\n\r\n        }\r\n        return defense;\r\n    }\r\n    // returns bonus if piece is protecting its king row\r\n    public backBonus(row: number) {\r\n        if (this.maximizingPlayer === 1 && row === 0) {\r\n            return 100;\r\n        }\r\n        if (this.maximizingPlayer === 2 && row === 7) {\r\n            return 100;\r\n        }\r\n        return 0;\r\n    }\r\n    // returns bonus depending on how close piece is to the middle\r\n    public middleBonus(row: number, col: number) {\r\n        return 100 - ((Math.abs(4 - col) + Math.abs(4 - row)) * 10);\r\n    }\r\n\r\n    // get number of pieces on original board and update global variables\r\n    public getBoardStatus(game: Game) {\r\n        let numRows = game.board.length;\r\n        let numCols = game.board[0].length;\r\n        this.numAllyPieces = 0;\r\n        this.numAllyKings = 0;\r\n        this.numOppPieces = 0;\r\n        this.numOppKings = 0;\r\n\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (this.maximizingPlayer === 1) {\r\n                    switch (game.board[i][j]) {\r\n                        case 1:\r\n                            this.numAllyPieces++;\r\n                            break;\r\n                        case 2:\r\n                            this.numOppPieces++;\r\n                            break;\r\n                        case 3:\r\n                            this.numAllyKings++;\r\n                            break;\r\n                        case 4:\r\n                            this.numOppKings++;\r\n                            break;\r\n                    }\r\n                }\r\n                else {\r\n                    switch (game.board[i][j]) {\r\n                        case 1:\r\n                            this.numOppPieces++;\r\n                            break;\r\n                        case 2:\r\n                            this.numAllyPieces++;\r\n                            break;\r\n                        case 3:\r\n                            this.numOppKings++;\r\n                            break;\r\n                        case 4:\r\n                            this.numAllyKings++;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport default Computer;","\r\nimport Game from './game';\r\nimport Computer from './computer';\r\nimport Move from './move';\r\n\r\n\r\nexport const initialState = { \r\n  actionsToSend: [],\r\n  character: 'sber',\r\n  respectfulAppeal: true,\r\n\r\n  //The initial setup\r\n\r\n  russianRules: false,\r\n  /*\r\n  backwardDirection: true,\r\n  players: [{isRobot: true}, {isRobot: false}],\r\n  playerTurn: 2,\r\n  */\r\n\r\n  backwardDirection: false,\r\n  players: [{isRobot: false}, {isRobot: true}],\r\n  playerTurn: 1,\r\n\r\n\r\n  // с клавиатуры выбирали поле\r\n  hasArrowSelectedItem: false,\r\n  arrowSelectedItemRow: 4, arrowSelectedItemCol: 4,\r\n\r\n  // Здесь счетчик\r\n  isContiniousMoving: 0,\r\n  continiousMoving: [],\r\n  continiousCaptured: [],\r\n\r\n  // какая-то шашка выбрана. после любого хода сбрасывается\r\n  hasSelectedItem: false,\r\n  selectedItemRow: 0, selectedItemCol: 0,\r\n\r\n  // 1 -> player 1 normal pieces, 2 -> player 2 normal pieces, 3 -> player 1 kings, 4 -> player 2 kings\r\n  // Нормальное начальное состояние\r\n  /*\r\n  gameBoard : [\r\n    [0, 11, 0, 21, 0, 31, 0, 41],\r\n    [51, 0, 61, 0, 71, 0, 81, 0],\r\n    [0, 91, 0, 103, 0, 111, 0, 121],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [134, 0, 142, 0, 152, 0, 162, 0],\r\n    [0, 172, 0, 182, 0, 192, 0, 202],\r\n    [212, 0, 222, 0, 232, 0, 242, 0]\r\n  ],\r\n  */\r\n  // нули для копирования\r\n  /*\r\n  gameBoard : [\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0]\r\n  ],\r\n  */\r\n\r\n\r\n  /*\r\n  gameBoard : [\r\n    [0, 0, 0, 0, 0, 0, 0, 11],\r\n    [21, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [12, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 22, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 33],\r\n    [0, 0, 0, 0, 0, 0, 0, 0]\r\n  ],\r\n  gameBoard : [\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 12, 0, 0, 0, 0, 0, 11],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 23, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0]\r\n  ],\r\n  */\r\n  /*\r\n  gameBoard : [\r\n    [0, 11, 0, 21, 0, 0, 0, 41],\r\n    [51, 0, 61, 0, 71, 0, 81, 0],\r\n    [0, 91, 0, 0, 0, 111, 0, 0],\r\n    [202, 0, 0, 0, 501, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 401, 0, 402],\r\n    [134, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 172, 0, 182, 0, 0, 0, 0],\r\n    [212, 0, 222, 0, 232, 0, 242, 0]\r\n  ],\r\n  */\r\n\r\n  gameBoard : [\r\n    [0, 0, 0, 0, 0, 24, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 12, 0, 0, 0, 11, 0, 21],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [32, 0, 42, 0, 0, 0, 52, 0],\r\n    [0, 0, 0, 0, 0, 0, 0, 0],\r\n    [0, 0, 62, 0, 0, 0, 0, 0]\r\n  ],\r\n\r\n\r\n  //arrays to store the instances\r\n  pieces : [],\r\n  tiles : []\r\n\r\n};\r\n\r\n\r\n\r\n\r\n/*\r\ntype Note = {\r\n  id: string;\r\n  title: string;\r\n  completed: boolean;\r\n};\r\n*/\r\n\r\ntype ActionToSend = {\r\n  id: string;\r\n  Action: { action: any };\r\n}\r\n\r\ntype State = {\r\n  //notes: Array<Note>;\r\n  actionsToSend: Array<ActionToSend>,\r\n\r\n  character: string,\r\n  respectfulAppeal: boolean,\r\n\r\n  russianRules: boolean,\r\n  backwardDirection: boolean,\r\n  players: {isRobot: boolean}[],\r\n  playerTurn: number,\r\n\r\n  hasArrowSelectedItem: boolean,\r\n  arrowSelectedItemRow: number, arrowSelectedItemCol: number,\r\n\r\n  hasSelectedItem: boolean,\r\n  selectedItemRow: number, selectedItemCol: number,\r\n\r\n  isContiniousMoving: number,\r\n  continiousMoving: {y: number, x: number}[],\r\n  continiousCaptured: {y: number, x: number}[],\r\n\r\n  gameBoard: number[][],\r\n  pieces : string[],\r\n  tiles : string[]\r\n\r\n};\r\n\r\ntype Action =\r\n  | {\r\n    type: \"init\";\r\n  }\r\n  | {\r\n    type: \"go\";\r\n    coord: number;\r\n    }\r\n  | {\r\n    type: \"go_enemy\";\r\n    coord: number;\r\n  }\r\n  | {\r\n    type: \"tile_click\";\r\n    row: number;\r\n    column: number;\r\n  }\r\n  | {\r\n    type: \"piece_click\";\r\n    row: number;\r\n    column: number;\r\n  }\r\n  | {\r\n    type: \"arrow_down\"\r\n  }\r\n  | {\r\n    type: \"arrow_up\"\r\n  }\r\n  | {\r\n    type: \"arrow_left\"\r\n  }\r\n  | {\r\n    type: \"arrow_right\"\r\n  }\r\n  | {\r\n    type: \"arrow_ok\"\r\n  }\r\n  | {\r\n    type: \"move_robot\"; // первый ход робота (хотя можно запускать и чтобы робот сделал ход за человека его шашками)\r\n  }\r\n  | {\r\n    type: \"continue_move_by_robot\" // следующие ходы робота\r\n  };\r\n\r\n\r\nfunction getLegalMoves(state: State)\r\n{\r\n  // Есть ли эта шашка возможных ходах\r\n  let checkers = new Game();\r\n  // Важно, чтобы -1 заполнились там, где нельзя ничего ставить\r\n  checkers.newGame();\r\n  // Текущее состояние\r\n  checkers.setCurrentState(state.gameBoard, state.playerTurn, 1);\r\n  checkers.russianRules=state.russianRules;\r\n  let legalMoves = checkers.getLegalMoves(checkers.board);\r\n  return legalMoves;\r\n}  \r\n\r\n\r\n// повторяющиеся в разных местах действия. правильность хода проверяется в другом месте (до этого)\r\n// учитывается переход хода\r\nfunction doMove(state: State, move: Move)\r\n{\r\n  let newBoard: number[][]=[];\r\n  state.gameBoard.forEach(line => {\r\n   newBoard.push(line.slice());\r\n  });\r\n\r\n  // Записываем нули туда, где были срубленные шашки\r\n  if (move.listCaptureCol.length>0)\r\n  {\r\n    // На самом деле реализуем только один шаг\r\n    let row=move.listCaptureRow[0];\r\n    let col=move.listCaptureCol[0];\r\n    newBoard[row][col] = 0;\r\n  }\r\n\r\n  if (move.listCaptureCol.length>1)\r\n  {\r\n    // Ход не переходит\r\n    let checker=newBoard[move.initialRow][move.initialCol];\r\n    newBoard[move.initialRow][move.initialCol] = 0;\r\n\r\n    if ((move.listVisitedRow[0]===7&&checker%10===1)||(move.listVisitedRow[0]===0&&checker%10===2))\r\n    {\r\n      checker+=2;\r\n    }\r\n\r\n    newBoard[move.listVisitedRow[0]][move.listVisitedCol[0]] = checker;\r\n\r\n    // \r\n    let continiousMoving=[];\r\n    let continiousCaptured=[];\r\n    for (let i=0; i<move.listVisitedRow.length; i++)\r\n    {\r\n      continiousMoving.push({y:move.listVisitedRow[i], x:move.listVisitedCol[i]});\r\n      continiousCaptured.push({y:move.listCaptureRow[i], x:move.listCaptureCol[i]});\r\n    }\r\n\r\n    // Игрок может ходить дальше только этой шашкой и только продолжать рубить\r\n    if (state.players[state.playerTurn-1])\r\n    {\r\n      return {\r\n        ...state,\r\n        gameBoard: newBoard,\r\n        isContiniousMoving: 1,\r\n        continiousMoving: continiousMoving,\r\n        continiousCaptured: continiousCaptured,\r\n        // сразу выделим эту шашку\r\n        hasSelectedItem: true,\r\n        selectedItemRow: move.listVisitedRow[0], selectedItemCol:move.listVisitedCol[0]\r\n      };\r\n  \r\n    }\r\n    \r\n    // Это робот\r\n    return {\r\n      ...state,\r\n      gameBoard: newBoard,\r\n      isContiniousMoving: 1,\r\n      continiousMoving: continiousMoving,\r\n      continiousCaptured: continiousCaptured,\r\n      // не важно, что это робот, но после хода сбрасываем выделенную шашку\r\n      hasSelectedItem: false\r\n    };\r\n  }\r\n\r\n  // Обычный ход, либо последний срубленный\r\n  let checker=newBoard[move.startRow][move.startCol];\r\n  newBoard[move.startRow][move.startCol] = 0;\r\n  if ((move.endRow===7&&checker%10===1)||(move.endRow===0&&checker%10===2))\r\n  {\r\n    checker+=2;\r\n  }\r\n  newBoard[move.endRow][move.endCol] = checker;\r\n // Ход переходит\r\n  return {\r\n    ...state,\r\n    gameBoard: newBoard,\r\n    isContiniousMoving: 0,\r\n    playerTurn: state.playerTurn===1?2:1,\r\n    hasSelectedItem: false\r\n  };\r\n}\r\n\r\nexport const reducer = (state: State, action: Action) => {\r\n\r\n  switch (action.type) {\r\n\r\n    case \"go\":\r\n      return {\r\n        ...state\r\n      };\r\n\r\n    case \"go_enemy\":\r\n      return {\r\n        ...state\r\n      };\r\n\r\n\r\n    case \"tile_click\":\r\n      //move piece when tile is clicked\r\n\r\n      /*\r\n    //make sure a piece is selected\r\n    if ($('.selected').length != 0) {\r\n      //find the tile object being clicked\r\n      var tileID = $(this).attr(\"id\").replace(/tile/, '');\r\n      var tile = tiles[tileID];\r\n      //find the piece being selected\r\n      var piece = pieces[$('.selected').attr(\"id\")];\r\n      //check if the tile is in range from the object\r\n      var inRange = tile.inRange(piece);\r\n      if (inRange != 'wrong') {\r\n        //if the move needed is jump, then move it but also check if another move can be made (double and triple jumps)\r\n        if (inRange == 'jump') {\r\n          if (piece.opponentJump(tile)) {\r\n            piece.move(tile);\r\n            if (piece.canJumpAny()) {\r\n              // Board.changePlayerTurn(); //change back to original since another turn can be made\r\n              piece.element.addClass('selected');\r\n              // exist continuous jump, you are not allowed to de-select this piece or select other pieces\r\n              Board.continuousjump = true;\r\n            } else {\r\n              Board.changePlayerTurn()\r\n            }\r\n          }\r\n          //if it's regular then move it if no jumping is available\r\n        } else if (inRange == 'regular' && !Board.jumpexist) {\r\n          if (!piece.canJumpAny()) {\r\n            piece.move(tile);\r\n            Board.changePlayerTurn()\r\n          } else {\r\n            alert(\"You must jump when possible!\");\r\n          }\r\n        }\r\n      }\r\n    }\r\n      */\r\n     let newBoard: number[][]=[];\r\n     state.gameBoard.forEach(line => {\r\n      newBoard.push(line.slice());\r\n     });\r\n\r\n     if (state.hasSelectedItem)\r\n     {\r\n       // это для теста, чтобы можно было двигать любые фигуры\r\n       let color=newBoard[state.selectedItemRow][state.selectedItemCol];\r\n      newBoard[state.selectedItemRow][state.selectedItemCol] = 0;\r\n      newBoard[action.row][action.column] = color;// state.playerTurn;\r\n     }\r\n\r\n      return {\r\n        ...state,\r\n        gameBoard: newBoard\r\n        // TODO включить переход хода\r\n        //playerTurn: state.playerTurn===1?2:1\r\n      };\r\n  \r\n\r\n    case \"piece_click\":\r\n      //select the piece on click if it is the player's turn\r\n\r\n    /*\r\n    var selected;\r\n    var isPlayersTurn = ($(this).parent().attr(\"class\").split(' ')[0] == \"player\" + Board.playerTurn + \"pieces\");\r\n    if (isPlayersTurn) {\r\n      if (!Board.continuousjump && pieces[$(this).attr(\"id\")].allowedtomove) {\r\n        if ($(this).hasClass('selected')) selected = true;\r\n        $('.piece').each(function (index) {\r\n          $('.piece').eq(index).removeClass('selected')\r\n        });\r\n        if (!selected) {\r\n          $(this).addClass('selected');\r\n        }\r\n      } else {\r\n        let exist = \"jump exist for other pieces, that piece is not allowed to move\"\r\n        let continuous = \"continuous jump exist, you have to jump the same piece\"\r\n        let message = !Board.continuousjump ? exist : continuous\r\n        console.log(message)\r\n      }\r\n    }\r\n\r\n    */\r\n    return {\r\n      ...state,\r\n      hasSelectedItem: true,\r\n      selectedItemRow: action.row,\r\n      selectedItemCol: action.column\r\n    };\r\n\r\n    case \"arrow_down\":\r\n      return {\r\n        ...state,\r\n        hasArrowSelectedItem: true,\r\n        //arrowSelectedItemRow: !state.backwardDirection?(state.arrowSelectedItemRow>=7?7:state.arrowSelectedItemRow+1):(state.arrowSelectedItemRow>0?state.arrowSelectedItemRow-1:0)\r\n        arrowSelectedItemRow: state.arrowSelectedItemRow>=7?7:state.arrowSelectedItemRow+1\r\n      };\r\n\r\n    case \"arrow_up\":\r\n      return {\r\n        ...state,\r\n        hasArrowSelectedItem: true,\r\n        //arrowSelectedItemRow: state.backwardDirection?(state.arrowSelectedItemRow>=7?7:state.arrowSelectedItemRow+1):(state.arrowSelectedItemRow>0?state.arrowSelectedItemRow-1:0)\r\n        arrowSelectedItemRow: state.arrowSelectedItemRow>0?state.arrowSelectedItemRow-1:0\r\n      };\r\n\r\n    case \"arrow_right\":\r\n      return {\r\n        ...state,\r\n        hasArrowSelectedItem: true,\r\n        //arrowSelectedItemCol: !state.backwardDirection?(state.arrowSelectedItemCol>=7?7:state.arrowSelectedItemCol+1):(state.arrowSelectedItemCol>0?state.arrowSelectedItemCol-1:0)\r\n        arrowSelectedItemCol: state.arrowSelectedItemCol>=7?7:state.arrowSelectedItemCol+1\r\n      };\r\n\r\n\r\n    case \"arrow_left\":\r\n      return {\r\n        ...state,\r\n        hasArrowSelectedItem: true,\r\n        //arrowSelectedItemCol: state.backwardDirection?(state.arrowSelectedItemCol>=7?7:state.arrowSelectedItemCol+1):(state.arrowSelectedItemCol>0?state.arrowSelectedItemCol-1:0)\r\n        arrowSelectedItemCol: state.arrowSelectedItemCol>0?state.arrowSelectedItemCol-1:0\r\n      };\r\n\r\n    case \"arrow_ok\":\r\n    {\r\n      // если не был курсор на экране, просто включим его, без обработки\r\n      if (state.hasArrowSelectedItem)\r\n      {\r\n        let checker=state.gameBoard[state.arrowSelectedItemRow][state.arrowSelectedItemCol];\r\n        // поле, где есть шашка\r\n        if (checker>0)\r\n        {\r\n          // если это шашка игрока\r\n          if (checker%10===state.playerTurn||checker%10===state.playerTurn+2)\r\n          {\r\n            let legalMoves=getLegalMoves(state);\r\n            if (legalMoves.length!==0)\r\n            {\r\n              let foundedMove=null;\r\n              legalMoves.forEach(move => {\r\n                if (move.listCaptureRow.length>0)\r\n                {\r\n                  if (move.initialRow===state.arrowSelectedItemRow&&move.initialCol===state.arrowSelectedItemCol)\r\n                  {\r\n                    foundedMove=move;\r\n                  }\r\n                } else\r\n                {\r\n                  if (move.startRow===state.arrowSelectedItemRow&&move.startCol===state.arrowSelectedItemCol)\r\n                  {\r\n                    foundedMove=move;\r\n                  }\r\n                }\r\n              });\r\n              if (foundedMove!==null)\r\n              {\r\n                // Выделаем шашку, которой собрался ходить игрок\r\n                return {\r\n                  ...state,\r\n                  hasArrowSelectedItem: true,\r\n                  hasSelectedItem: true,\r\n                  selectedItemRow: state.arrowSelectedItemRow,\r\n                  selectedItemCol: state.arrowSelectedItemCol\r\n                };\r\n  \r\n              }\r\n            }\r\n          }\r\n        } else\r\n        if (checker===0)\r\n        {\r\n          // пустое поле, если сюда выделенная шашка ходит, то делаем ход\r\n          if (state.hasSelectedItem)\r\n          {\r\n            let legalMoves=getLegalMoves(state);\r\n            let foundedMove=null;\r\n            legalMoves.forEach(move => {\r\n              if (move.listCaptureCol.length>0)\r\n              {\r\n                // если есть срубленные, надо смотреть координаты initial \r\n                if (move.initialRow===state.selectedItemRow&&move.initialCol===state.selectedItemCol&&move.listVisitedRow[0]===state.arrowSelectedItemRow&&move.listVisitedCol[0]===state.arrowSelectedItemCol)\r\n                  foundedMove=move;\r\n              } else {\r\n                if (move.startRow===state.selectedItemRow&&move.startCol===state.selectedItemCol&&move.endRow===state.arrowSelectedItemRow&&move.endCol===state.arrowSelectedItemCol)\r\n                  foundedMove=move;\r\n              }\r\n          });\r\n            if (foundedMove!==null)\r\n            {\r\n              // делаем ход\r\n              let newState=doMove(state, foundedMove);\r\n              //\r\n              return {\r\n                ...newState,\r\n                hasArrowSelectedItem: true,\r\n                // это выставляется в doMove - если ходил игрок и дальше должен рубить этой же шашкой, то выделение остается\r\n                //hasSelectedItem: false\r\n              };\r\n\r\n            }\r\n\r\n          }\r\n        }\r\n\r\n      }\r\n      return {\r\n        ...state,\r\n        hasArrowSelectedItem: true\r\n      }\r\n    }\r\n  \r\n\r\n\r\n    case \"move_robot\": // первый ход робота (хотя можно запускать и чтобы робот сделал ход за человека его шашками)\r\n    {\r\n      let checkers = new Game();\r\n      let computerPlayer = new Computer(state.playerTurn, 1);\r\n      // Важно, чтобы -1 заполнились там, где нельзя ничего ставить\r\n      checkers.newGame();\r\n      // Текущее состояние\r\n      checkers.setCurrentState(state.gameBoard, state.playerTurn, 3);\r\n      checkers.russianRules=state.russianRules;\r\n\r\n      let legalMoves = checkers.getLegalMoves(checkers.board);\r\n      if (legalMoves.length===0) {\r\n        console.log(\"I am lost!\");\r\n          //gameOver = true;\r\n          //console.log(\"Player 2 Wins!\");\r\n          //continue;\r\n      } else {\r\n      //console.log(\"Player 1's Turn: \");\r\n      //checkers.printListMoves(legalMoves);\r\n      //if (player1IsComputer){\r\n          let move = computerPlayer.alphaBetaSearch(checkers);\r\n          if (move)\r\n          {\r\n            checkers.applyMove(move, checkers.board);\r\n            console.log(\"Player Chose: \");\r\n            checkers.printMove(move);\r\n\r\n            let newState=doMove(state, move);\r\n\r\n             return {\r\n               ...newState\r\n               //playerTurn: state.playerTurn===1?2:1\r\n             };\r\n       \r\n\r\n          }\r\n      }\r\n      //}\r\n      //checkers.printNote();\r\n      //checkers.printBoard();\r\n\r\n    \r\n\r\n      return {\r\n        ...state,\r\n        playerTurn: state.playerTurn===1?2:1\r\n      };\r\n    }\r\n\r\n    case \"continue_move_by_robot\":\r\n    {\r\n      // продолжаем только если это робот\r\n      // для человека просто ход ограничивается этой шашкой (и она при этом выделена всегда)\r\n      if (state.isContiniousMoving===0||!state.players[state.playerTurn-1].isRobot)\r\n        return state;\r\n\r\n      let newBoard: number[][]=[];\r\n      state.gameBoard.forEach(line => {\r\n       newBoard.push(line.slice());\r\n      });\r\n\r\n      // Тут будет 1,2,... потому, что нулевой ход уже сделан\r\n      let i=state.isContiniousMoving;\r\n      // Столько ходов осталось\r\n      let checker=newBoard[state.continiousMoving[i-1].y][state.continiousMoving[i-1].x];\r\n      // Откуда переместились\r\n      let restMoves=state.continiousMoving.length-state.isContiniousMoving;\r\n      newBoard[state.continiousMoving[i-1].y][state.continiousMoving[i-1].x]=0;\r\n      // Срубленные\r\n      newBoard[state.continiousCaptured[i].y][state.continiousCaptured[i].x]=0;\r\n      // Переход в дамки\r\n      if ((state.continiousMoving[i].y===7&&checker%10===1)||(state.continiousMoving[i].y===0&&checker%10===2))\r\n      {\r\n        checker+=2;\r\n      }\r\n      // Новая координата\r\n      newBoard[state.continiousMoving[i].y][state.continiousMoving[i].x] = checker;\r\n\r\n      if (restMoves>1)\r\n      {\r\n        // Ход не переходит\r\n        return {\r\n          ...state,\r\n          gameBoard: newBoard,\r\n          isContiniousMoving: state.isContiniousMoving+1\r\n        };\r\n      }\r\n    \r\n      // Обычный ход, либо последний срубленный\r\n    \r\n    \r\n      // Ход переходит\r\n      return {\r\n        ...state,\r\n        gameBoard: newBoard,\r\n        isContiniousMoving: 0,\r\n        playerTurn: state.playerTurn===1?2:1\r\n      };\r\n    }\r\n\r\n    default:\r\n      throw new Error();\r\n  }\r\n};\r\n","import logo from './logo.svg';\r\nimport './App.css';\r\n\r\nimport Game from './game';\r\nimport Computer from './computer';\r\nimport Move from './move';\r\n\r\nimport king1 from './img/king1.png';\r\nimport king2 from './img/king2.png';\r\n\r\nimport React, {\r\n  FC,\r\n  memo,\r\n  useReducer,\r\n  //useState,\r\n  //useRef,\r\n  //useEffect,\r\n  //useLayoutEffect,\r\n  //RefObject,\r\n} from 'react';\r\n\r\n/*\r\nimport {\r\n  createSmartappDebugger,\r\n  createAssistant,\r\n  createRecordPlayer,\r\n  AssistantAppState,\r\n  AssistantSmartAppData,\r\n  AssistantCharacterType\r\n} from \"@sberdevices/assistant-client\";\r\n*/\r\n\r\nimport { initialState, reducer } from \"./store\";\r\nimport { background } from '@sberdevices/plasma-tokens';\r\nimport { Row } from '@sberdevices/ui';\r\n\r\nconst dictionary = [\"0vmin\", \"10vmin\", \"20vmin\", \"30vmin\", \"40vmin\", \"50vmin\", \"60vmin\", \"70vmin\", \"80vmin\", \"90vmin\"];\r\nconst label_coords =\r\n  [[0,1,0,2,0,3,0,4],\r\n   [5,0,6,0,7,0,8,0],\r\n   [0,9,0,10,0,11,0,12],\r\n   [13,0,14,0,15,0,16,0],\r\n   [0,17,0,18,0,19,0,20],\r\n   [21,0,22,0,23,0,24,0],\r\n   [0,25,0,26,0,27,0,28],\r\n   [29,0,30,0,31,0,32,0]\r\n  ];\r\n\r\n\r\n\r\n\r\nexport const App: FC = memo(() => {\r\n  const [appState, dispatch] = useReducer(reducer, initialState);\r\n\r\n  function downHandler(e: KeyboardEvent ) {\r\n    if (e.key==='ArrowDown')\r\n      dispatch({type: 'arrow_down'});\r\n    if (e.key==='ArrowUp')\r\n      dispatch({type: 'arrow_up'});\r\n    if (e.key==='ArrowLeft')\r\n      dispatch({type: 'arrow_left'});\r\n    if (e.key==='ArrowRight')\r\n      dispatch({type: 'arrow_right'});\r\n    if (e.key==='Enter')\r\n    {\r\n      e.preventDefault();\r\n      dispatch({type: 'arrow_ok'});\r\n    }\r\n\r\n  }\r\n\r\n  function processContinueMove()\r\n  {\r\n    dispatch({type: 'continue_move_by_robot'});\r\n  }\r\n\r\n  function processRobotMove()\r\n  {\r\n    dispatch({type: 'move_robot'});\r\n  }\r\n  \r\n  \r\n\r\n  React.useEffect(() => {\r\n    window.addEventListener(\"keydown\", downHandler);\r\n    //window.addEventListener(\"keyup\", upHandler);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"keydown\", downHandler);\r\n      //window.removeEventListener(\"keyup\", upHandler);\r\n    }\r\n  });\r\n\r\n  React.useEffect(() => {\r\n    // Обрабатываем изменения счетчика ходов, а также смены игрока\r\n    // если ход робота\r\n    if (appState.players[appState.playerTurn-1].isRobot)\r\n    {\r\n      // если продолжение, то ждем 3 секунды и двигаем дальше\r\n      if (appState.isContiniousMoving!==0)\r\n      {\r\n        setTimeout(() => processContinueMove(), 3100);\r\n      } else {\r\n        // надо сделать обычный ход\r\n        //dispatch({type: 'move_robot'});\r\n        // однако надо начать думать над ходом не раньше, чем доска отрисуется (0.2сек)\r\n        setTimeout(() => processRobotMove(), 210);\r\n\r\n      }\r\n    } else {\r\n      // играет человек\r\n    }\r\n  }, [appState.isContiniousMoving, appState.playerTurn]);\r\n\r\n\r\n  function changePlayerTurn() {\r\n    /*\r\n    if (this.playerTurn == 1) {\r\n      this.playerTurn = 2;\r\n      $('.turn').css(\"background\", \"linear-gradient(to right, transparent 50%, #BEEE62 50%)\");\r\n    } else {\r\n      this.playerTurn = 1;\r\n      $('.turn').css(\"background\", \"linear-gradient(to right, #BEEE62 50%, transparent 50%)\");\r\n    }\r\n    this.check_if_jump_exist()\r\n    return;\r\n    */\r\n  }\r\n\r\n  function handleTileClick(row: any, column: any, e:any) {\r\n    e.preventDefault();\r\n    dispatch({type: 'tile_click', row: row, column: column});\r\n  }\r\n  \r\n\r\nfunction _renderTiles()\r\n{\r\n  let values = [];\r\n\r\n  let countTiles=0;\r\n\r\n  for (let row=0; row<appState.gameBoard.length; row++) { //row is the index\r\n    for (let column=0; column<appState.gameBoard[row].length; column++) { //column is the index\r\n      //whole set of if statements control where the tiles and pieces should be placed on the board\r\n      if (row % 2 === 1) {\r\n        if (column % 2 === 0) {\r\n\r\n          const divStyle = {\r\n            top: appState.backwardDirection?dictionary[7-row]:dictionary[row],\r\n            left: appState.backwardDirection?dictionary[7-column]:dictionary[column],\r\n            color: \"#FF3333\"\r\n          };          \r\n      \r\n          values.push(<div key={countTiles.toString()} className=\"tile\" id={\"tile\"+countTiles.toString()} style={divStyle} onClick={(e)=>handleTileClick(row, column, e)}>{label_coords[appState.backwardDirection?7-row:row][appState.backwardDirection?7-column:column].toString()}</div>);\r\n          countTiles++;\r\n\r\n        }\r\n      } else {\r\n        if (column % 2 === 1) {\r\n          //countTiles = this.tileRender(row, column, countTiles)\r\n          const divStyle = {\r\n            top: appState.backwardDirection?dictionary[7-row]:dictionary[row],\r\n            left: appState.backwardDirection?dictionary[7-column]:dictionary[column],\r\n            color: \"#FF3333\"\r\n          };          \r\n      \r\n          values.push(<div key={countTiles.toString()} className=\"tile\" id={\"tile\"+countTiles.toString()} style={divStyle} onClick={(e)=>handleTileClick(row, column, e)}>{label_coords[appState.backwardDirection?7-row:row][appState.backwardDirection?7-column:column].toString()}</div>);\r\n          countTiles++;\r\n\r\n        }\r\n      }\r\n      /*\r\n      if (this.board[row][column] == 1) {\r\n        countPieces = this.playerPiecesRender(1, row, column, countPieces)\r\n      } else if (this.board[row][column] == 2) {\r\n        countPieces = this.playerPiecesRender(2, row, column, countPieces)\r\n      }\r\n      */\r\n    }\r\n  }\r\n\r\n  return  values;\r\n}\r\n\r\n\r\nfunction handlePieceClick(row: any, column: any, e:any) {\r\n  e.preventDefault();\r\n  dispatch({type: 'piece_click', row: row, column: column});\r\n}\r\n\r\n\r\nfunction _renderPieces(playerId: number)\r\n{\r\n  let values = [];\r\n  let keys = [];\r\n  let values_sorted = [];\r\n\r\n  let countPieces=0;\r\n\r\n  for (let row=0; row<appState.gameBoard.length; row++) { //row is the index\r\n    for (let column=0; column<appState.gameBoard[row].length; column++) { //column is the index\r\n      let checker=appState.gameBoard[row][column];\r\n      let checkersType=checker%10;\r\n      // 1, 3 - первый игрок, 2, 4 - второй\r\n      if (checkersType === playerId || checkersType === playerId+2) {\r\n        // TODO\r\n        // this.element.css(\"backgroundImage\", \"url('img/king\" + this.player + \".png')\");\r\n\r\n        const divStyle = checkersType===3?{\r\n          top: dictionary[row],\r\n          left: dictionary[column],\r\n          backgroundImage: \"url(\" + king1 + \")\"\r\n        }:checkersType===4?{\r\n          top: dictionary[row],\r\n          left: dictionary[column],\r\n          backgroundImage: \"url(\" + king2 + \")\"\r\n        }: {\r\n          top: dictionary[row],\r\n          left: dictionary[column]\r\n        };\r\n\r\n        let myClassName=appState.hasSelectedItem&&appState.selectedItemRow===row&&appState.selectedItemCol===column?\"piece selected\":\"piece\";\r\n      \r\n        values.push(<div key={Math.floor(checker/10).toString()} className={myClassName} id={\"piece\"+Math.floor(checker/10).toString()} style={divStyle} onClick={(e)=>handlePieceClick(row,column,e)}></div>);\r\n        // чтобы порядок не менялся при перемещении шашек в другие точки\r\n        // (иначе не будет плавной анимации, в случае, когда меняется порядок (даже при неизменных id))\r\n        keys.push({checker:checker, idx: countPieces});\r\n        countPieces++;\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  keys.sort((a,b)=>a.checker-b.checker);\r\n\r\n  for (let i = 0; i < keys.length; i++) {  \r\n    values_sorted.push(values[keys[i].idx]);\r\n  }\r\n\r\n  return values_sorted;\r\n}\r\n\r\nfunction handleClearGameClick(e: any) {\r\n  e.preventDefault();\r\n  dispatch({type: 'move_robot'});\r\n}\r\n\r\nfunction handleKeyDown(e:any)\r\n{\r\n  console.debug(\"key\");\r\n}\r\n\r\nfunction _renderPult()\r\n{\r\n  let values=[];\r\n\r\n  if (appState.hasArrowSelectedItem)\r\n  {\r\n    /*\r\n    const divStyle = {\r\n      top: appState.backwardDirection?dictionary[7-appState.arrowSelectedItemRow]:dictionary[appState.arrowSelectedItemRow],\r\n      left: appState.backwardDirection?dictionary[7-appState.arrowSelectedItemCol]:dictionary[appState.arrowSelectedItemCol]\r\n    };\r\n    */          \r\n    const divStyle = {\r\n      top: dictionary[appState.arrowSelectedItemRow],\r\n      left: dictionary[appState.arrowSelectedItemCol]\r\n    };\r\n\r\n\r\n    values.push(<div className=\"selection\" style={divStyle}></div>);\r\n  }\r\n\r\n  return values;\r\n\r\n}\r\n\r\n\r\n  return (\r\n    <div className=\"App\">\r\n    <div className=\"column\">\r\n    <div className=\"info\">\r\n      <h1>Checkers</h1>\r\n      <hr/>\r\n      <p>Made by codethejason for <a href=\"http://fossasia.org\">FOSSASIA</a> 2015.</p>\r\n    </div>\r\n    <div className=\"stats\">\r\n      <h2>Game Statistics</h2>\r\n      <div className=\"wrapper\">\r\n      <div id=\"player1\">\r\n        <h3>Player 1 (Top)</h3>\r\n      </div>\r\n      <div id=\"player2\">\r\n        <h3>Player 2 (Bottom)</h3>\r\n      </div>\r\n      </div>\r\n      <div className=\"clearfix\"></div>\r\n      <div className=\"turn\" style={appState.playerTurn===1?{background: \"linear-gradient(to right, #BEEE62 50%, transparent 50%)\"}:{background: \"linear-gradient(to right, transparent 50%, #BEEE62 50%)\"}}></div>\r\n      <span id=\"winner\"></span>\r\n      <button id=\"cleargame\" onClick={handleClearGameClick}>Reset Game</button>\r\n    </div>\r\n  </div>\r\n\r\n    <div className=\"column\">\r\n    <div id=\"board\" onKeyDown={(e)=>handleKeyDown(e)}>\r\n      <div className=\"tiles\">\r\n      {_renderTiles()}\r\n      </div>\r\n      <div className=\"pieces\">\r\n        <div className=\"player1pieces\">\r\n        {_renderPieces(1)}\r\n        </div>\r\n        <div className=\"player2pieces\">\r\n        {_renderPieces(2)}\r\n        </div>\r\n      </div>\r\n      <div className=\"pult\">\r\n        {_renderPult()}\r\n      </div>\r\n    </div>\r\n    </div>\r\n    </div>\r\n  );\r\n\r\n\r\n    /*\r\n    <div className=\"App\">\r\n      <header className=\"App-header\">\r\n        <img src={logo} className=\"App-logo\" alt=\"logo\" />\r\n        <p>\r\n          Edit <code>src/App.tsx</code> and save to reload.\r\n        </p>\r\n        <a\r\n          className=\"App-link\"\r\n          href=\"https://reactjs.org\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Learn React\r\n        </a>\r\n      </header>\r\n    </div>\r\n    */\r\n});","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport {App} from './App';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>\r\n  ,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}